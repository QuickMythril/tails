#!/usr/bin/env ruby

# This script reports which binary/source packages that can be safely
# deleted from the stable APT suite in our custom repo. It requires a
# .build-manifest as the source for which packages that are used
# during build and thus cannot be deleted.

begin
  require 'debian'
rescue LoadError
  raise 'please install the ruby-debian package'
end
require 'yaml'

class NoSource < StandardError
end

def source_package(package)
  matches = []
  APT_SOURCES.each_package do |dsc|
    # The -dbg(sym) packages are not listed, so we look for the
    # original package's source instead, which will be the same.
    matches << dsc if dsc.binary.include?(package.sub(/-dbg(sym)?$/, ''))
  end
  raise NoSource, "found no source package for #{package}" if matches.size.zero?

  raise "found multiple source packages for #{package}" if matches.size > 1

  matches.first.package
end

def binary_packages(package)
  APT_SOURCES[package].binary
end

manifest_path = ARGV[0]
raise 'please provide a .build-manifest as the only argument' if manifest_path.nil?

current_branch=`git symbolic-ref HEAD | sed 's,refs/heads/,,'`
allowed_branches = ['stable', 'devel']
if ! allowed_branches.include?(current_branch)
  raise "we only support checking the following branches' " \
        "custom APT suites: #{allowed_branches.join(', ')}"
end
begin
  apt_repo_hostnames = [
    'deb.tails.boum.org',
    'umjqavufhoix3smyq6az2sx4istmuvsgmz4bq5u5x56rnayejoo6l2qd.onion',
  ]
  apt_repo_filenames = apt_repo_hostnames.map do |hostname|
    "/var/lib/apt/lists/#{hostname}_dists_#{current_branch}_main_source_Sources"
  end
  apt_repo_filename = apt_repo_filenames.find do |filename|
    File.exist?(filename)
  end
  APT_SOURCES = Debian::Sources.new(apt_repo_filename).freeze
rescue
  raise 'could not find Tails custom APT repo\'s sources, ' \
        "please add this to your APT sources:\n" \
        "deb-src [arch=amd64] http://deb.tails.boum.org/ #{current_branch} main"
end

all_source_packages = []
used_source_packages = []
binary_cruft_candidates = []

manifest = YAML.load_file(manifest_path)
custom_packages = `ssh reprepro@incoming.deb.tails.boum.org reprepro list stable`
custom_packages.each_line(chomp: true) do |line|
  type, name, version = line.split
  if type['source']
    all_source_packages << name
  else
    installed = manifest['packages']['binary'].find { |x| x['package'] == name }
    if installed.nil? || version != installed['version']
      binary_cruft_candidates << name
    else
      used_source_packages << source_package(name)
    end
  end
end

puts 'Binary packages that are not used:'
binary_cruft_candidates.each do |p|
  begin
    next if used_source_packages.include?(source_package(p))
  rescue NoSource
    # If we don't have a source for a package, it should be a package
    # we forgot to clean up when we removed its sources.
  end
  puts " - #{p}"
end
puts

puts 'Source packages that are not used:'
source_cruft = all_source_packages.uniq - used_source_packages
source_cruft.each { |p| puts " - #{p}" }
