#!/usr/bin/python3
"""
This service listens on a unix domain socket and provides a simple interface to run privileged actions.

It is meant to be run as root.
"""

import os
import sys
import stat
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
import socketserver
import logging
import socket
import time
from subprocess import Popen

from tinyrpc.protocols.jsonrpc import  JSONRPCProtocol, JSONRPCParseError
from tinyrpc.protocols import  RPCRequest, RPCResponse
from tinyrpc.exc import InvalidRequestError

from tailslib.systemd import systemd_ready
from tailslib.gnome import gnome_env_vars
from tailslib import LIVE_USERNAME

log = logging.getLogger("tca-helper")


class ForkingUnixServer(socketserver.ForkingMixIn, socketserver.UnixStreamServer):
    allow_reuse_address = True
    timeout = None


def run_user_command(cmd: list):
    drop = ["runuser", "-u", LIVE_USERNAME]
    env = ["env", *gnome_env_vars()]

    args = [*drop, "--", *env, *cmd]
    Popen(args)


class Handler(socketserver.StreamRequestHandler):
    """
    This class implements the JSON-RPC line-protocol + some glue code to call relevant actions.

    The protocol is basically JSON-RPC with some more restrictions:
     - requests are in a single line
     - response are in a single line

    This is not supported at the moment, but could:
     - server-initiated messages (ie: signals)
    """

    MAX_LINESIZE = 1024

    valid_commands = {"open-unsafebrowser", "open-tbb", "open-networkmonitor"}

    spawn_user_commands = {  # some commands just mean "run this specified commands as LIVE_USERNAME, please"
        "open-unsafebrowser": ["sudo", "-n", "unsafe-browser"],
        "open-tbb": ["tor-browser"],
        "open-networkmonitor": ["gnome-system-monitor"],
    }

    protocol = JSONRPCProtocol()

    def handle_line(self, line: bytes) -> RPCResponse:
        try:
            req = self.protocol.parse_request(line)
        except JSONRPCParseError as exc:
            return exc.error_respond()
        except InvalidRequestError as exc:
            return exc.error_respond()

        try:
            return self.handle_request(req)
        except Exception:
            return req.error_respond(error="Server error")

    def handle_request(self, req: RPCRequest) -> RPCResponse:
        if req.method not in self.valid_commands:
            return req.error_respond(error="Invalid method")
        if req.method in self.spawn_user_commands:
            run_user_command(self.spawn_user_commands[req.method])
            return req.respond(result={"ok": True})
        return req.error_respond(error="Method not implemented")

    def handle(self):
        log = logging.getLogger("traffic")

        while True:
            peek_ahead = self.request.recv(self.MAX_LINESIZE, socket.MSG_PEEK)
            if not peek_ahead:
                return
            if b"\n" not in peek_ahead:
                time.sleep(0.1)
                continue
            request_length = peek_ahead.find(b"\n")
            line_in = self.request.recv(request_length + 1).rstrip(b"\n").decode("utf8")
            if not line_in:
                continue
            log.debug("<- %s", line_in)
            response = self.handle_line(line_in.lstrip())
            output = response.serialize()
            log.debug("-> %s", output)
            output += "\n"
            self.request.send(output.encode("utf8"))


def main():
    if os.getuid() != 0:
        print("%s must be run as root" % sys.argv[0], file=sys.stderr)
        sys.exit(1)
    p = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)
    p.add_argument("--listen", metavar="SOCKET-PATH", default="/run/tca-portal.sock")
    p.add_argument(
        "--log-level",
        metavar="LEVEL",
        choices=["DEBUG", "INFO", "WARNING", "CRITICAL"],
        default="INFO",
    )
    args = p.parse_args()

    logging.basicConfig(level=args.log_level)

    if os.path.exists(args.listen) and stat.S_ISSOCK(os.stat(args.listen).st_mode):
        os.remove(args.listen)
    with ForkingUnixServer(args.listen, Handler) as server:
        os.chmod(args.listen, 0o600)
        systemd_ready()
        log.info("Listening on %s", args.listen)
        server.serve_forever()


if __name__ == "__main__":
    main()
