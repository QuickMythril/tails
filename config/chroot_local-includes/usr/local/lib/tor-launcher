#!/usr/bin/python3

from pathlib import Path
import time
import logging
import os
import sys, json
import socket
from stem.control import Controller
import stem.socket
from typing import List, Optional, Dict, Any

log = logging.getLogger("tor-launcher")


class StemFDSocket(stem.socket.ControlSocket):
    def __init__(self, fd: int):
        super().__init__()
        self.fd = fd

    @property
    def path(self) -> str:
        """
        I don't think that's ever called, but let's implement it

        returns sth like socket:[12345678], which is not great
        """
        fname = "/proc/%d/fd/%d" % (os.getpid(), self.fd)
        return Path(fname).resolve().name

    def _make_socket(self):
        """
        We don't need to create a new socket: let's reuse the FD!
        """
        return socket.socket(fileno=self.fd)


def recover_fd_from_parent() -> tuple:
    fds = [int(fd) for fd in os.getenv("INHERIT_FD", "").split(",")]
    # fds[0] must be a socket to Tor Control Port
    # fds[1] must be a rw fd for settings file

    controller = None
    # FIXME: Controller need to take its specific kind of socket as argument
    #        creating a stem.socket.BaseSocket.ControlSocket from a low-level
    #        socket is not trivial
    #        So this line is actually buggy
    socket = StemFDSocket(fds[1])
    controller = Controller(socket)

    configfile = os.fdopen(fds[0], "r+")

    return (configfile, controller)


# PROXY_TYPES is a sequence of Tor options related to proxing.
#     Those exact values are also used by TorConnectionProxy
PROXY_TYPES = ("Socks4Proxy", "Socks5Proxy", "HTTPSProxy")


class TorConnectionProxy:
    """configuration item for proxy configuration"""

    def __init__(self, address, port: int, proxy_type):
        # TODO: check that proxy_types is one of 4,5,https
        if proxy_type not in PROXY_TYPES:
            raise ValueError("Invalid proxy type: `%s`" % proxy_type)
        self.proxy_type = proxy_type
        self.address = address
        self.port = port

    @classmethod
    def from_obj(cls, obj):
        proxy = cls(
            proxy_type=obj["proxy_type"], address=obj["address"], port=int(obj["port"])
        )
        return proxy

    def to_dict(self):
        return {
            "proxy_type": self.proxy_type,
            "address": self.address,
            "port": self.port,
        }

    @classmethod
    def from_tor_value(cls, proxy_type, val):
        address, port = val.split(":")
        return cls(address, int(port), proxy_type)

    def to_tor_value_str(self) -> str:
        return "%s:%d" % (self.address, self.port)


class TorConnectionConfig:
    def __init__(self, bridges: list = [], proxy: TorConnectionProxy = None):
        self.bridges: List[str] = bridges
        self.proxy: Optional[TorConnectionProxy] = proxy

    @classmethod
    def load_from_tor_stem(cls, stem_controller: Controller):
        bridges: List[str] = []
        if stem_controller.get_conf("UseBridges") != "0":
            bridges = stem_controller.get_conf("Bridge", multiple=True)

        proxy = None
        for proxy_type in PROXY_TYPES:
            val = stem_controller.get_conf(proxy_type)
            if val is not None:
                proxy = TorConnectionProxy.from_tor_value(proxy_type, val)
                break

        config = cls(bridges=bridges, proxy=proxy)

        return config

    @classmethod
    def load_from_dict(cls, obj):
        """this method is suitable to retrieve configuration from a JSON object"""
        config = cls()
        config.bridges = obj.get("bridges", [])
        proxy = obj.get("proxy", None)
        if proxy is not None:
            config.proxy = TorConnectionProxy.from_obj(proxy)
        else:
            config.proxy = None
        return config

    def to_dict(self) -> dict:
        return {
            "bridges": self.bridges,
            "proxy": self.proxy.to_dict() if self.proxy is not None else None,
        }

    def to_tor_conf(self) -> Dict[str, Any]:
        """
        returns a dict whose output fits to stem.control.Controller.set_options
        """
        r: Dict[str, Any] = {}
        r["UseBridges"] = "1" if self.bridges else "0"
        r["Bridge"] = self.bridges
        for proxy_type in PROXY_TYPES:
            r[proxy_type] = None
            if self.proxy is not None and self.proxy.proxy_type == proxy_type:
                r[proxy_type] = self.proxy.to_tor_value_str()
        return r


class TorLauncherUtils:
    def __init__(self, stem_controller: Controller, config_buf):
        """
        Arguments:
        stem_controller -- an already connected and authorized stem Controller
        config_buf -- an already open read-write buffer to the configuration file
        """
        self.stem_controller = stem_controller
        self.config_buf = config_buf
        self.tor_connection_config = None

    def load_conf(self):
        self.read_conf()
        if self.tor_connection_config is None:
            self.tor_connection_config = TorConnectionConfig.load_from_tor_stem(
                self.stem_controller
            )

    def save_conf(self):
        if self.tor_connection_config is None:
            return
        self.config_buf.seek(0, os.SEEK_SET)
        self.config_buf.write(
            json.dumps(self.tor_connection_config.to_dict(), indent=2)
        )
        self.config_buf.truncate()

    def read_conf(self):
        self.config_buf.seek(0, os.SEEK_END)
        size = self.config_buf.tell()
        if not size:
            log.debug("Empty config file")
            return
        self.config_buf.seek(0)
        try:
            obj = json.load(self.config_buf)
        except JSONDecodeError:
            log.warning("Invalid config file")
            return
        finally:
            self.config_buf.seek(0)
        self.tor_connection_config = TorConnectionConfig.load_from_dict(obj)

    def apply_conf(self):
        self.stem_controller.set_conf("DisableNetwork", "1")
        self.stem_controller.set_options(self.tor_connection_config.to_tor_conf())
        self.stem_controller.set_conf("DisableNetwork", "0")

    def tor_has_bootstrapped(self) -> bool:
        resp = self.stem_controller.get_info("status/bootstrap-phase")
        if resp is None:
            log.warn("No response from ControlPort")
            return False
        parts = resp.split(" ")
        if parts[0] != "NOTICE":  # it is WARN
            return False

        if int(parts[2].split("=")[1]) != 100:
            return False

        # shall we really do also those checks?
        resp = self.stem_controller.get_info("status/circuit-established")
        if resp is None:
            log.warn("No response from ControlPort")
            return False
        if not bool(int(resp)):
            return False

        return True


def test():
    from pprint import pprint

    controller = Controller.from_socket_file()
    controller.authenticate()

    if len(sys.argv) > 1:
        conf = TorConnectionConfig.load_from_dict(json.load(open(sys.argv[1])))
    else:
        conf = TorConnectionConfig.load_from_tor_stem(controller)
    conf = conf.to_tor_conf()
    pprint(conf)
    if len(sys.argv) > 1:
        controller.set_options(conf)


def main():
    conf, controller = recover_fd_from_parent()
    controller.authenticate(password=None)
    launcher = TorLauncherUtils(controller, conf)
    launcher.load_conf()
    print(json.dumps(launcher.tor_connection_config.to_dict(), indent=4))
    launcher.apply_conf()

    bootstrapped = False
    for i in range(30):
        time.sleep((i+1) * 0.5)
        is_ok = launcher.tor_has_bootstrapped()
        if is_ok:
            bootstrapped = True
            break

    if not bootstrapped:
        print("Bootstrap error!", file=sys.stderr)
        return 1

    launcher.save_conf()
    print(json.dumps(launcher.tor_connection_config.to_dict(), indent=4))


if __name__ == "__main__":
    # test()
    logging.basicConfig(level=logging.DEBUG)
    main()
