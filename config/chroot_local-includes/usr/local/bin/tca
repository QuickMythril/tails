#!/usr/bin/python3
"""
wrapper over TCA.

elevates to sudo, then connect to whatever is needed and drop privileges again.
"""
import os
import sys
import gettext
import shutil
from pathlib import Path
from subprocess import check_output, CalledProcessError, Popen
from logging import getLogger, basicConfig

from tailslib import LIVE_USERNAME
from tailslib.gnome import gnome_env_vars
from tailslib.greeter import get_greeter_variable_bool

import tca.config

NETNS = "torlaunch"
log = getLogger(__name__)


def main():
    if os.getuid() != 0:
        os.execvpe("sudo", ["sudo", "-n", __file__] + sys.argv[1:], env=os.environ)
        return

    python_bin = "/usr/bin/python3"
    program = "/usr/lib/python3/dist-packages/tca/application.py"

    try:
        running_processes = int(
            check_output(
                [
                    "pgrep",
                    "--count",
                    "--uid",
                    LIVE_USERNAME,
                    "--full",
                    "--exact",
                    "%s %s" % (python_bin, program),
                ]
            )
        )
    except CalledProcessError as exc:
        if exc.returncode == 1:
            running_processes = 0
        else:
            raise
    if running_processes:
        print("TCA is already running", file=sys.stderr)
        return

    confdir = Path("~%s/.config/tca/" % LIVE_USERNAME).expanduser()
    conffile = confdir / "tca.conf"
    confdir.mkdir(mode=0o700, exist_ok=True)
    shutil.chown(str(confdir), user=0, group=0)
    confdir.chmod(0o700)
    conffile.touch(mode=0o600)

    portalsock = "/run/tca-portal.sock"

    connect_drop = [
        "/usr/local/lib/connect-drop",
        "-c",
        "FILE:%s:r+" % conffile,
        "-c",
        "UNIX:%s" % portalsock,
        "--",
    ]
    ch_netns = ["/bin/ip", "netns", "exec", NETNS]
    runuser = ["/sbin/runuser", "-u", LIVE_USERNAME]
    # base bwrap sharing most of the system
    bwrap = ["bwrap", "--bind", "/", "/", "--proc", "/proc", "--dev", "/dev"]
    # passes data to us
    bwrap += [
        "--bind",
        os.path.join("/tmp/netns-specific/", NETNS),
        "/tmp/shared-with-me/",
    ]
    # hide data not for us
    bwrap += ["--tmpfs", "/tmp/netns-specific/"]
    envcmd = [
        "env",
        *gnome_env_vars(),
        "AT_SPI_BUS_ADDRESS=unix:path=/tmp/shared-with-me/at.sock",
        "IBUS_ADDRESS=unix:path=/tmp/shared-with-me/ibus.sock",
        # uncomment this if you want to tweak the UI
        # 'GTK_DEBUG=interactive',
    ]
    if get_greeter_variable_bool("TAILS_NETWORK"):
        tcacmd = [python_bin, program]
    else:
        tcacmd = get_zenity_cmd()
        connect_drop = []

    # We run tca with several wrappers to accomplish our privilege-isolation-magic:
    # connect_drop: opens a privileged file and pass FD to new process
    # ch_netns: enter the new namespace
    # runuser: change back to unprivileged user
    # bwrap: this is probably the most complicated; what it does is sharing /tmp/netns-specific/$NETNS on
    # /tmp/shared-with-me/ and hide /tmp/netns-specific/ . The result is that TCA will be able to access
    # sockets that would otherwise be unreachable. See also tails-{a11y,ibus}-proxy-netns@.service
    # envcmd: set the "right" environment; this means getting all "normal" gnome variables, AND clarifying
    #         where is the {a11y,ibus} bus, which is related to bwrap

    args = [
        *connect_drop,
        *ch_netns,
        *runuser,
        "--",
        *bwrap,
        *envcmd,
        *tcacmd,
        *sys.argv[1:],
    ]
    log.info("%s", args)

    os.execv(args[0], args)


def get_zenity_cmd() -> list:
    _ = gettext.gettext
    zenity = [
        "zenity",
        "--error",
        "--no-wrap",
        "--title",
        _(tca.config.APPLICATION_TITLE),
        "--text",
        _(
            "You are in Offline mode, "
            "therefore you cannot use Tor Connection assistant.\n\n"
            "Reboot and enable networking if you want to connect to Tor."
        ),
    ]
    return zenity


if __name__ == "__main__":
    basicConfig(level="DEBUG")
    main()
